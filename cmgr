#!/bin/bash
# cmgr - Claude Desktop Manager
# Manages multiple isolated instances of Claude Desktop

set -euo pipefail

# Get absolute path to script directory, resolving symlinks
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
echo "Main script directory: ${SCRIPT_DIR}"

# Make sure templates directory exists
if [ ! -d "${SCRIPT_DIR}/templates" ]; then
    echo "WARNING: Templates directory not found at ${SCRIPT_DIR}/templates"
    # Try to create it if it doesn't exist
    mkdir -p "${SCRIPT_DIR}/templates/scripts"
fi

# Load libraries
source "${SCRIPT_DIR}/lib/dependencies.sh"
source "${SCRIPT_DIR}/lib/sandbox.sh"
source "${SCRIPT_DIR}/lib/installer.sh"
source "${SCRIPT_DIR}/lib/instance.sh"
source "${SCRIPT_DIR}/lib/config.sh"
source "${SCRIPT_DIR}/lib/desktop.sh"
source "${SCRIPT_DIR}/lib/help.sh"
source "${SCRIPT_DIR}/lib/patches.sh"
source "${SCRIPT_DIR}/lib/mcp_ports.sh"
source "${SCRIPT_DIR}/lib/mcp_gui.sh"

# Check for basic dependencies
if ! check_dependencies; then
    echo "Required dependencies are missing. Please install them as indicated above."
    exit 1
fi

# Global variables - handle sudo properly
if [ "$(id -u)" -eq 0 ] && [ -n "${SUDO_USER:-}" ]; then
    # Running as root with sudo
    ORIGINAL_USER="${SUDO_USER}"
    ORIGINAL_HOME=$(eval echo ~${SUDO_USER})
    CMGR_HOME="${ORIGINAL_HOME}/.cmgr"
    SANDBOX_BASE="${ORIGINAL_HOME}/sandboxes"
    
    # Make sure we don't use root's home
    export HOME="${ORIGINAL_HOME}"
else
    # Running as regular user
    CMGR_HOME="${HOME}/.cmgr"
    SANDBOX_BASE="${HOME}/sandboxes"
fi

CMGR_CACHE="${CMGR_HOME}/cache"
CMGR_REGISTRY="${CMGR_HOME}/registry.json"

# Ensure basic directories exist
mkdir -p "${CMGR_HOME}" "${CMGR_CACHE}" "${SANDBOX_BASE}" "${CMGR_HOME}/logs"

# Initialize and validate registry files
if [ ! -f "${CMGR_REGISTRY}" ]; then
    echo '{"instances": {}}' > "${CMGR_REGISTRY}"
fi

# Validate main registry
if ! jq empty "${CMGR_REGISTRY}" 2>/dev/null; then
    echo "WARNING: Instance registry file is corrupted. Creating backup and reinitializing."
    cp "${CMGR_REGISTRY}" "${CMGR_REGISTRY}.corrupted.$(date +%s)" 2>/dev/null || true
    echo '{"instances": {}}' > "${CMGR_REGISTRY}"
fi

# Validate port registry if it exists
PORT_REGISTRY="${CMGR_HOME}/port_registry.json"
if [ -f "${PORT_REGISTRY}" ] && ! jq empty "${PORT_REGISTRY}" 2>/dev/null; then
    echo "WARNING: Port registry file is corrupted. It will be fixed when MCP tools are configured."
fi

# Fix ownership if running as root
if [ "$(id -u)" -eq 0 ] && [ -n "${SUDO_USER:-}" ]; then
    chown -R "${SUDO_USER}:$(id -gn "${SUDO_USER}")" "${CMGR_HOME}" "${SANDBOX_BASE}"
fi

# Command handlers
cmd_create() {
    local instance_name="$1"
    shift
    create_instance "$instance_name" "$@"
}

cmd_list() {
    list_instances
}

cmd_start() {
    local instance_name="$1"
    start_instance "$instance_name"
}

cmd_stop() {
    local instance_name="$1"
    stop_instance "$instance_name"
}

cmd_remove() {
    local instance_name="$1"
    remove_instance "$instance_name"
}

cmd_config() {
    local instance_name="$1"
    shift
    configure_instance "$instance_name" "$@"
}

cmd_alias() {
    local instance_name="$1"
    local alias_name="${2:-}"
    create_alias "$instance_name" "$alias_name"
}

cmd_desktop() {
    local instance_name="$1"
    create_desktop_shortcut "$instance_name"
}

cmd_mcp() {
    local instance_name="$1"
    shift
    configure_mcp "$instance_name" "$@"
}

cmd_import_config() {
    local instance_name="$1"
    local source="${2:-host}"
    import_mcp_config "$instance_name" "$source"
}

cmd_execute() {
    local instance_name="$1"
    shift
    execute_claude_command "$instance_name" "$@"
}

cmd_mcp_gui() {
    # Launch the global MCP manager GUI
    launch_mcp_gui
}

cmd_fix_warnings() {
    local instance_name="$1"
    
    if [ -z "$instance_name" ]; then
        echo "Error: Missing instance name"
        cmd_help
        exit 1
    fi
    
    # Check if instance exists
    if ! instance_exists "$instance_name"; then
        echo "Error: Instance '$instance_name' does not exist."
        return 1
    fi
    
    echo "Applying MaxListenersExceededWarning fix to instance '$instance_name'..."
    
    # Get the sandbox directory
    local sandbox_home="${SANDBOX_BASE}/${instance_name}"
    mkdir -p "${sandbox_home}/.config/claude-desktop"
    mkdir -p "${sandbox_home}/.config/Claude/electron"
    
    # Use absolute path for template files
    local template_dir="${SCRIPT_DIR}/templates"
    if [ ! -d "${template_dir}" ]; then
        # Try to find the templates directory using absolute path
        template_dir="$(cd "${SCRIPT_DIR}" && cd .. && pwd)/templates"
        # For safety, check if we're in the project root
        if [ ! -d "${template_dir}" ]; then
            # Last resort, use the path directly
            template_dir="/home/awarth/Devstuff/claude-desktop-manager/templates"
        fi
    fi
    
    echo "Using templates directory: ${template_dir}"
    
    # Check if scripts directory exists
    local scripts_dir="${template_dir}/scripts"
    if [ ! -d "${scripts_dir}" ]; then
        scripts_dir="${template_dir}"
    fi
    
    # Create the fix-listeners.js script directly to avoid path issues
    local fix_listeners_script="${sandbox_home}/.config/claude-desktop/fix-listeners.js"
    echo "Creating fix-listeners.js at ${fix_listeners_script}"
    
    # Write the script content directly
    cat > "$fix_listeners_script" << 'EOF'
// Node.js script to patch Electron app code to fix MaxListenersExceededWarning
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Function to find .asar files (Electron app archives)
function findAsarFiles(startPath) {
  console.log(`Searching for asar files in: ${startPath}`);
  let results = [];
  
  try {
    // Check if the directory exists
    if (!fs.existsSync(startPath)) {
      console.log(`Directory not found: ${startPath}`);
      return results;
    }
    
    const files = fs.readdirSync(startPath);
    
    for (let file of files) {
      const filename = path.join(startPath, file);
      const stat = fs.lstatSync(filename);
      
      if (stat.isDirectory()) {
        // Recursively search directories
        results = results.concat(findAsarFiles(filename));
      } else if (filename.endsWith('.asar')) {
        // Found an asar file
        console.log(`Found asar file: ${filename}`);
        results.push(filename);
      }
    }
  } catch (error) {
    console.error(`Error searching directory ${startPath}:`, error);
  }
  
  return results;
}

// Main function to patch app files
async function patchAppFiles() {
  const appDir = process.argv[2] || process.cwd();
  console.log(`Starting app patching process in: ${appDir}`);
  
  try {
    // Find all asar files
    const asarFiles = findAsarFiles(appDir);
    
    if (asarFiles.length === 0) {
      console.log('No .asar files found. Trying to find loose app files...');
      
      // Try to find main process files directly
      const mainJsFiles = findMainJsFiles(appDir);
      
      if (mainJsFiles.length > 0) {
        for (const mainJsFile of mainJsFiles) {
          patchMainFile(mainJsFile);
        }
      } else {
        console.log('Could not find any main process files to patch.');
      }
      
      // Also look for electron.js, main.js, etc.
      const appFiles = [
        path.join(appDir, 'electron.js'),
        path.join(appDir, 'main.js'),
        path.join(appDir, 'app.js'),
        path.join(appDir, 'background.js'),
        path.join(appDir, 'dist', 'electron.js'),
        path.join(appDir, 'dist', 'main.js')
      ];
      
      for (const file of appFiles) {
        if (fs.existsSync(file)) {
          console.log(`Found app file: ${file}`);
          patchMainFile(file);
        }
      }
      
      return;
    }
    
    // Process each asar file
    for (const asarFile of asarFiles) {
      await processAsarFile(asarFile);
    }
    
    console.log('Patching process completed!');
  } catch (error) {
    console.error('Error in patching process:', error);
  }
}

// Find main.js files directly in the file system
function findMainJsFiles(startPath) {
  console.log(`Searching for main process JS files in: ${startPath}`);
  let results = [];
  
  try {
    if (!fs.existsSync(startPath)) {
      return results;
    }
    
    const files = fs.readdirSync(startPath);
    
    for (let file of files) {
      const filename = path.join(startPath, file);
      const stat = fs.lstatSync(filename);
      
      if (stat.isDirectory()) {
        results = results.concat(findMainJsFiles(filename));
      } else if (
        file === 'main.js' || 
        file === 'electron.js' || 
        file === 'background.js' ||
        file === 'app.js'
      ) {
        console.log(`Found potential main process file: ${filename}`);
        results.push(filename);
      }
    }
  } catch (error) {
    console.error(`Error searching directory ${startPath}:`, error);
  }
  
  return results;
}

// Process an asar file
async function processAsarFile(asarFile) {
  console.log(`Processing asar file: ${asarFile}`);
  
  // Create extraction directory
  const extractDir = `${asarFile}-extracted`;
  if (fs.existsSync(extractDir)) {
    console.log(`Removing existing extraction directory: ${extractDir}`);
    fs.rmSync(extractDir, { recursive: true, force: true });
  }
  
  fs.mkdirSync(extractDir, { recursive: true });
  
  try {
    // Extract asar file
    console.log(`Extracting asar to: ${extractDir}`);
    execSync(`npx asar extract "${asarFile}" "${extractDir}"`);
    
    // Find main.js files
    const mainJsFiles = findMainJsFiles(extractDir);
    
    if (mainJsFiles.length === 0) {
      console.log(`No main process files found in ${asarFile}`);
      return;
    }
    
    // Patch each main file
    for (const mainJsFile of mainJsFiles) {
      patchMainFile(mainJsFile);
    }
    
    // Re-pack the asar file
    console.log(`Repacking asar file: ${asarFile}`);
    
    // Create backup of original asar
    const backupFile = `${asarFile}.bak`;
    if (!fs.existsSync(backupFile)) {
      fs.copyFileSync(asarFile, backupFile);
      console.log(`Created backup of original asar: ${backupFile}`);
    }
    
    execSync(`npx asar pack "${extractDir}" "${asarFile}"`);
    console.log(`Repacked asar file: ${asarFile}`);
    
    // Clean up
    fs.rmSync(extractDir, { recursive: true, force: true });
    console.log(`Removed extraction directory: ${extractDir}`);
  } catch (error) {
    console.error(`Error processing asar file ${asarFile}:`, error);
  }
}

// Patch a main process file
function patchMainFile(filePath) {
  console.log(`Patching file: ${filePath}`);
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    
    // Check if file already patched
    if (content.includes('// CMGR PATCH: MaxListenersExceededWarning fix')) {
      console.log(`File ${filePath} already patched. Skipping.`);
      return;
    }
    
    // Add patching code at the beginning of the file
    const patch = `
// CMGR PATCH: MaxListenersExceededWarning fix
const events = require('events');
events.EventEmitter.defaultMaxListeners = 30;

// Patch WebContents to increase listeners
const { app, webContents } = require('electron');
app.on('web-contents-created', (event, contents) => {
  contents.setMaxListeners(30);
});

// Patch any emitter creation
const originalEmit = events.EventEmitter.prototype.emit;
events.EventEmitter.prototype.emit = function(type, ...args) {
  if (type === 'newListener' && this.listenerCount('newListener') === 0) {
    this.setMaxListeners(30);
  }
  return originalEmit.apply(this, [type, ...args]);
};

console.log('CMGR: Applied MaxListenersExceededWarning fix');

`;
    
    // Insert the patch at the beginning of the file
    content = patch + content;
    
    // Write the patched file
    fs.writeFileSync(filePath, content);
    console.log(`Successfully patched ${filePath}`);
  } catch (error) {
    console.error(`Error patching file ${filePath}:`, error);
  }
}

// Run the patching process
patchAppFiles();
EOF
    
    chmod +x "$fix_listeners_script"
    
    # Create the preload script directly
    local preload_script="${sandbox_home}/.config/claude-desktop/preload.js"
    local preload_script2="${sandbox_home}/.config/Claude/electron/preload.js"
    
    echo "Creating preload scripts at:"
    echo "  - ${preload_script}"
    echo "  - ${preload_script2}"
    
    # Write the same content to both locations
    cat > "$preload_script" << 'EOF'
// Enhanced preload.js - Fixes for common issues in Claude Desktop
// This script runs in the Electron process context

// Log that preload script is running
console.log('CMGR: Enhanced preload script initializing');

// Fix for MaxListenersExceededWarning
if (typeof process !== 'undefined') {
  try {
    const events = require('events');
    
    // Increase max listeners to a higher value (default is 10)
    events.EventEmitter.defaultMaxListeners = 30;
    console.log('CMGR: Set default max listeners to 30');
    
    // Patch individual emitters when they're created
    const originalEmit = events.EventEmitter.prototype.emit;
    events.EventEmitter.prototype.emit = function(type, ...args) {
      if (type === 'newListener' && this.listenerCount('newListener') === 0) {
        // When a new emitter gets its first listener, increase its limit
        if (this.setMaxListeners) {
          this.setMaxListeners(30);
        }
      }
      return originalEmit.apply(this, [type, ...args]);
    };
    
    // Load electron conditionally
    let electron;
    try {
      electron = require('electron');
      
      // Handle WebContents specifically
      if (electron.app) {
        // This runs in the main process
        console.log('CMGR: Running in main process, patching app.on(web-contents-created)');
        
        // Patch app when web contents are created
        electron.app.on('web-contents-created', (event, contents) => {
          console.log('CMGR: New WebContents created, increasing its max listeners');
          contents.setMaxListeners(30);
        });
      } else if (electron.remote && electron.remote.app) {
        // This runs in the renderer process with remote module
        console.log('CMGR: Running in renderer with remote, patching remote.app');
        
        electron.remote.app.on('web-contents-created', (event, contents) => {
          contents.setMaxListeners(30);
        });
      }
    } catch (electronError) {
      console.log('CMGR: Electron module not available in this context:', electronError.message);
    }
    
    console.log('CMGR: EventEmitter patching complete');
  } catch (error) {
    console.error('CMGR: Error patching EventEmitter:', error);
  }
}

// Get the instance name from environment variable
let instanceName = '';
if (typeof process !== 'undefined' && process.env && process.env.CLAUDE_INSTANCE) {
  instanceName = process.env.CLAUDE_INSTANCE;
  console.log('CMGR: Instance name detected:', instanceName);
}

// Set the window title to include the instance name
if (typeof window !== 'undefined' && instanceName) {
  // Function to update the title
  const updateTitle = () => {
    const originalTitle = document.title;
    
    // Only update if the title doesn't already contain our instance name
    if (!originalTitle.includes(`[${instanceName}]`)) {
      document.title = `${originalTitle} [${instanceName}]`;
      console.log('CMGR: Updated window title to:', document.title);
    }
  };
  
  // Update immediately if the document is already loaded
  if (document.readyState === 'complete') {
    updateTitle();
  }
  
  // Otherwise wait for the document to load
  window.addEventListener('load', updateTitle);
  
  // Set up a MutationObserver to detect title changes
  const titleObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (document.title && !document.title.includes(`[${instanceName}]`)) {
        updateTitle();
      }
    });
  });
  
  // Start observing the title element once it exists
  const observeTitleElement = () => {
    const titleElement = document.querySelector('title');
    if (titleElement) {
      titleObserver.observe(titleElement, { childList: true, subtree: true });
      console.log('CMGR: Title observer attached');
    } else {
      // If title element doesn't exist yet, try again later
      setTimeout(observeTitleElement, 500);
    }
  };
  
  // Start looking for the title element
  setTimeout(observeTitleElement, 500);
  
  // Also observe the document body for changes that might affect the title
  const bodyObserver = new MutationObserver(() => {
    updateTitle();
  });
  
  // Start observing once the body exists
  if (document.body) {
    bodyObserver.observe(document.body, { childList: true, subtree: true });
  } else {
    window.addEventListener('DOMContentLoaded', () => {
      bodyObserver.observe(document.body, { childList: true, subtree: true });
    });
  }
}

// Suppress specific warnings by overriding console.warn
if (typeof console !== 'undefined') {
  const originalWarn = console.warn;
  console.warn = function(...args) {
    // Check if this is a MaxListenersExceededWarning
    if (args[0] && typeof args[0] === 'string' && 
        (args[0].includes('MaxListenersExceededWarning') || 
         args[0].includes('Possible EventEmitter memory leak'))) {
      // Suppress this warning
      return;
    }
    
    // Pass through other warnings
    return originalWarn.apply(this, args);
  };
  
  console.log('CMGR: Console warnings for MaxListenersExceededWarning suppressed');
}

// Print a reminder at the end for verification
console.log('CMGR: Preload script initialization complete!');
EOF
    
    # Copy the content to the second location
    cp -f "$preload_script" "$preload_script2"
    
    # Run the fix-listeners.js script
    run_in_sandbox "$instance_name" bash -c "
        echo 'Running fix-listeners.js script...'
        
        # First check if nodejs is installed
        if ! command -v node &>/dev/null; then
            echo 'Installing Node.js for patching...'
            mkdir -p ~/.local/share/nodejs
            curl -sL https://nodejs.org/dist/v18.16.0/node-v18.16.0-linux-x64.tar.gz | tar xz -C ~/.local/share/nodejs --strip-components=1
            export PATH=~/.local/share/nodejs/bin:\$PATH
        fi
        
        # For deb installations
        if [ -d ~/.local/share/claude-desktop ] || [ -x ~/.local/bin/claude-desktop ]; then
            APP_DIR=\$(readlink -f ~/.local/share/claude-desktop || echo ~/.local/bin)
            echo \"Patching \$APP_DIR...\"
            node ~/.config/claude-desktop/fix-listeners.js \$APP_DIR
        fi
        
        # For AppImage installations
        APPIMAGE=\$(find ~/Downloads -name '*.AppImage' | head -1)
        if [ -n \"\$APPIMAGE\" ] && [ ! -f \"\$APPIMAGE.original\" ]; then
            echo 'Creating wrapper script for AppImage...'
            mv \"\$APPIMAGE\" \"\$APPIMAGE.original\"
            cat > \"\$APPIMAGE\" << 'EOF'
#!/bin/bash
# Wrapper script to prevent MaxListenersExceededWarning
export NODE_OPTIONS='--no-warnings'
export ELECTRON_NO_WARNINGS=1

SCRIPT_DIR=\"\$(cd \"\$(dirname \"\${BASH_SOURCE[0]}\")\" && pwd)\"
\"\$SCRIPT_DIR/\$(basename \"\$0\").original\" \"\$@\"
EOF
            chmod +x \"\$APPIMAGE\"
            echo 'AppImage wrapper created successfully!'
        fi
        
        # Update the Claude config to use preload script
        mkdir -p ~/.config/Claude
        CONFIG_FILE=~/.config/Claude/claude_desktop_config.json
        
        if [ -f \"\$CONFIG_FILE\" ]; then
            # Use jq if available
            if command -v jq &>/dev/null; then
                TMP_FILE=\"\$CONFIG_FILE.tmp\"
                jq '.electronInitScript = \"$HOME/.config/Claude/electron/preload.js\"' \"\$CONFIG_FILE\" > \"\$TMP_FILE\"
                mv \"\$TMP_FILE\" \"\$CONFIG_FILE\"
            else
                # Simple sed-based approach if jq is not available
                sed -i 's/\"electronInitScript\":.*/\"electronInitScript\": \"$HOME\\/.config\\/Claude\\/electron\\/preload.js\",/g' \"\$CONFIG_FILE\"
                if ! grep -q \"electronInitScript\" \"\$CONFIG_FILE\"; then
                    # Add the configuration if not present
                    sed -i 's/{/{\"electronInitScript\": \"$HOME\\/.config\\/Claude\\/electron\\/preload.js\",/g' \"\$CONFIG_FILE\"
                fi
            fi
        else
            # Create new config file
            mkdir -p ~/.config/Claude
            echo '{
  \"electronInitScript\": \"$HOME/.config/Claude/electron/preload.js\"
}' > \"\$CONFIG_FILE\"
        fi
        
        echo 'MaxListenersExceededWarning fix completed!'
    "
    
    echo "✓ Fix applied successfully! Please restart the instance for changes to take effect."
    return 0
}

cmd_update_title() {
    local instance_name="$1"
    
    if [ -z "$instance_name" ]; then
        echo "Error: Missing instance name"
        cmd_help
        exit 1
    fi
    
    # Check if instance exists
    if ! instance_exists "$instance_name"; then
        echo "Error: Instance '$instance_name' does not exist."
        return 1
    fi
    
    echo "Updating window title configuration for instance '$instance_name'..."
    
    # Get the sandbox directory
    local sandbox_home="${SANDBOX_BASE}/${instance_name}"
    mkdir -p "${sandbox_home}/.config/claude-desktop"
    
    # Create the update-window-titles script directly in the sandbox
    local update_script="${sandbox_home}/.config/claude-desktop/update-window-titles.sh"
    
    # Write the script content directly
    cat > "$update_script" << 'EOF'
#!/bin/bash
# update-window-titles.sh - Updates desktop entries and preload scripts to customize window titles

set -e

SANDBOX_HOME="$HOME"
INSTANCE_NAME="${CLAUDE_INSTANCE:-claude}"

echo "Updating window title configuration for instance: $INSTANCE_NAME"

# Update desktop entries
for desktop_file in "$SANDBOX_HOME/.local/share/applications/"*claude*.desktop; do
    if [ -f "$desktop_file" ]; then
        echo "Updating desktop entry: $desktop_file"
        
        # Add instance name to title
        sed -i "s/^Name=.*/Name=Claude Desktop ($INSTANCE_NAME)/" "$desktop_file"
        sed -i "s/^Comment=.*/Comment=Claude Desktop AI Assistant ($INSTANCE_NAME instance)/" "$desktop_file"
        
        # Update StartupWMClass
        sed -i "s/^StartupWMClass=.*/StartupWMClass=Claude-$INSTANCE_NAME/" "$desktop_file"
        
        # Add environment variable to Exec line if not already present
        if ! grep -q "CLAUDE_INSTANCE=$INSTANCE_NAME" "$desktop_file"; then
            sed -i "s/^Exec=.*/Exec=env CLAUDE_INSTANCE=$INSTANCE_NAME LIBVA_DRIVER_NAME=dummy &/" "$desktop_file"
        fi
        
        echo "✓ Desktop entry updated"
    fi
done

# Ensure preload script exists and contains window title code
for config_dir in "$SANDBOX_HOME/.config/claude-desktop" "$SANDBOX_HOME/.config/Claude/electron"; do
    mkdir -p "$config_dir"
    preload_file="$config_dir/preload.js"
    
    if [ -f "$preload_file" ]; then
        # Check if window title code is already in the preload script
        if ! grep -q "updateTitle" "$preload_file"; then
            echo "Updating preload script: $preload_file"
            cat >> "$preload_file" <<'PRELOADEOF'

// Window title customization for instance: $INSTANCE_NAME
if (typeof window !== 'undefined') {
  const updateTitle = () => {
    if (!document.title.includes('[$INSTANCE_NAME]')) {
      document.title = document.title + ' [$INSTANCE_NAME]';
    }
  };
  
  if (document.readyState === 'complete') {
    updateTitle();
  }
  
  window.addEventListener('load', updateTitle);
  
  // Check periodically for title changes
  setInterval(updateTitle, 1000);
}
PRELOADEOF
            echo "✓ Preload script updated"
        else
            echo "✓ Preload script already contains window title customization"
        fi
    else
        echo "Creating new preload script: $preload_file"
        cat > "$preload_file" <<'PRELOADEOF'
// Claude Desktop Manager preload script
// Custom preload script for instance: $INSTANCE_NAME

// Window title customization
if (typeof window !== 'undefined') {
  const updateTitle = () => {
    if (!document.title.includes('[$INSTANCE_NAME]')) {
      document.title = document.title + ' [$INSTANCE_NAME]';
    }
  };
  
  if (document.readyState === 'complete') {
    updateTitle();
  }
  
  window.addEventListener('load', updateTitle);
  
  // Check periodically for title changes
  setInterval(updateTitle, 1000);
}

// Fix for MaxListenersExceededWarning
if (typeof process !== 'undefined') {
  try {
    const events = require('events');
    events.EventEmitter.defaultMaxListeners = 30;
  } catch (error) {
    console.error('Error setting default max listeners:', error);
  }
}
PRELOADEOF
        echo "✓ New preload script created"
    fi
done

# Update configuration to use preload script
config_file="$SANDBOX_HOME/.config/Claude/claude_desktop_config.json"
mkdir -p "$(dirname "$config_file")"

if [ -f "$config_file" ]; then
    # Check if config already has preload script
    if ! grep -q "electronInitScript" "$config_file"; then
        echo "Updating Claude Desktop config to use preload script"
        # Simple sed approach that works in most cases
        sed -i 's/{/{\"electronInitScript\": \"$HOME\/.config\/Claude\/electron\/preload.js\", /' "$config_file"
        echo "✓ Configuration updated"
    else
        echo "✓ Configuration already contains preload script setting"
    fi
else
    echo "Creating new Claude Desktop config"
    cat > "$config_file" <<'CONFIGEOF'
{
  "electronInitScript": "$HOME/.config/Claude/electron/preload.js"
}
CONFIGEOF
    echo "✓ New configuration created"
fi

echo "Window title customization complete for instance: $INSTANCE_NAME"
echo "Please restart Claude Desktop for changes to take effect."
EOF
    
    chmod +x "$update_script"
    
    # Run the script in the sandbox
    run_in_sandbox "$instance_name" bash -c "CLAUDE_INSTANCE=\"$instance_name\" ~/.config/claude-desktop/update-window-titles.sh"
    
    echo "✓ Window title configuration updated. Please restart the instance for changes to take effect."
    return 0
}

cmd_verify_isolation() {
    local instance_name="$1"
    
    if [ -z "$instance_name" ]; then
        echo "Error: Missing instance name"
        cmd_help
        exit 1
    fi
    
    # Check if instance exists
    if ! instance_exists "$instance_name"; then
        echo "Error: Instance '$instance_name' does not exist."
        return 1
    fi
    
    echo "Verifying sandbox isolation for instance '$instance_name'..."
    
    # Copy the verification script to the sandbox if it exists
    local sandbox_home="${SANDBOX_BASE}/${instance_name}"
    mkdir -p "${sandbox_home}/.config/claude-desktop"
    
    if [ -f "${SCRIPT_DIR}/templates/scripts/verify-isolation.sh" ]; then
        cp "${SCRIPT_DIR}/templates/scripts/verify-isolation.sh" "${sandbox_home}/.config/claude-desktop/"
        chmod +x "${sandbox_home}/.config/claude-desktop/verify-isolation.sh"
    else
        echo "Creating isolation verification script..."
        cat > "${sandbox_home}/.config/claude-desktop/verify-isolation.sh" << 'EOF'
#!/bin/bash
# verify-isolation.sh - Script to verify sandbox isolation is working correctly

# Bold text formatting
BOLD="\e[1m"
RESET="\e[0m"
GREEN="\e[32m"
RED="\e[31m"
YELLOW="\e[33m"

echo -e "${BOLD}Claude Desktop Manager - Sandbox Isolation Verification${RESET}"
echo "============================================================"

# Check if HOME is set correctly
echo -e "\n${BOLD}1. Checking HOME environment variable:${RESET}"
if [ "$HOME" != "/home/claude" ]; then
    echo -e "${RED}✗ HOME is incorrectly set to: $HOME${RESET}"
    echo "  It should be: /home/claude"
else
    echo -e "${GREEN}✓ HOME environment variable is correctly set to /home/claude${RESET}"
fi

# Check if real home is accessible
echo -e "\n${BOLD}2. Checking if real user home directory is inaccessible:${RESET}"
if [ -d "/home/awarth" ]; then
    echo -e "${RED}✗ CRITICAL: Can access real home at /home/awarth${RESET}"
    echo "  This indicates isolation failure!"
    ls -la "/home/awarth" | head -5
else
    echo -e "${GREEN}✓ Cannot access real home at /home/awarth (expected behavior)${RESET}"
fi

# Check if only the sandbox home exists
echo -e "\n${BOLD}3. Checking if /home contains only the sandbox directory:${RESET}"
if [ ! -d "/home/claude" ]; then
    echo -e "${RED}✗ ERROR: Cannot access sandbox home at /home/claude!${RESET}"
elif [ "$(ls -la /home | grep -v claude | grep -c ^d)" -gt 0 ]; then
    echo -e "${YELLOW}⚠ WARNING: Additional directories found in /home besides claude:${RESET}"
    ls -la /home
else
    echo -e "${GREEN}✓ Only the sandbox home directory (/home/claude) is accessible${RESET}"
fi

# Check if MCP configuration is using correct paths
echo -e "\n${BOLD}4. Checking MCP configuration paths:${RESET}"
config_file="$HOME/.config/Claude/claude_desktop_config.json"
if [ -f "$config_file" ]; then
    echo -e "${GREEN}✓ MCP configuration file exists at: $config_file${RESET}"
    
    # Check for paths in MCP config
    if grep -q "/home/awarth" "$config_file"; then
        echo -e "${RED}✗ Found references to /home/awarth in MCP config!${RESET}"
        grep -n "/home/awarth" "$config_file"
    else
        echo -e "${GREEN}✓ No references to real home directory in MCP config${RESET}"
    fi
    
    # Check for environment path
    if grep -q "\"HOME\": \"/home/claude\"" "$config_file"; then
        echo -e "${GREEN}✓ HOME environment correctly set to /home/claude in MCP config${RESET}"
    else
        echo -e "${YELLOW}⚠ HOME environment may not be correctly set in MCP config${RESET}"
        grep -n "\"HOME\"" "$config_file" || echo "  No HOME environment entry found"
    fi
else
    echo -e "${YELLOW}⚠ MCP configuration file not found at: $config_file${RESET}"
fi

# Check access to real config
echo -e "\n${BOLD}5. Testing access to real MCP configuration:${RESET}"
if [ -d "/home/awarth/.config/Claude" ]; then
    echo -e "${RED}✗ CRITICAL: Can access real Claude config at /home/awarth/.config/Claude${RESET}"
else
    echo -e "${GREEN}✓ Cannot access real Claude config (expected behavior)${RESET}"
fi

# Summarize findings
echo -e "\n${BOLD}Summary:${RESET}"
if [ "$HOME" != "/home/claude" ] || [ -d "/home/awarth" ] || [ -d "/home/awarth/.config/Claude" ]; then
    echo -e "${RED}❌ Sandbox isolation FAILED - Please check the sandbox configuration${RESET}"
else
    echo -e "${GREEN}✅ Sandbox isolation appears to be working correctly${RESET}"
fi

echo -e "\nFor more information, see README-ISOLATION-FIX.md"
EOF
        chmod +x "${sandbox_home}/.config/claude-desktop/verify-isolation.sh"
    fi
    
    # Run the verification script in the sandbox
    run_in_sandbox "$instance_name" bash -c "~/.config/claude-desktop/verify-isolation.sh"
    
    return $?
}

cmd_build() {
    echo "Building latest Claude Desktop .deb package..."
    
    # Check if we have the necessary dependencies
    echo "Checking dependencies..."
    for cmd in p7zip wget wrestool icotool convert nodejs npm; do
        if ! command -v "$cmd" &> /dev/null; then
            echo "❌ Missing dependency: $cmd"
            echo "Please install the required dependencies before proceeding."
            return 1
        fi
    done
    echo "✓ All dependencies satisfied."
    
    # Create build directory
    local build_dir="${CMGR_CACHE}/build_$(date +%s)"
    mkdir -p "$build_dir"
    
    echo "Using build directory: $build_dir"
    
    # Set up paths and variables
    local format="deb"
    local cleanup="yes"
    local architecture=$(dpkg --print-architecture)
    local CLAUDE_DOWNLOAD_URL=""
    
    # Set the download URL based on architecture
    if [ "$architecture" = "amd64" ]; then
        CLAUDE_DOWNLOAD_URL="https://storage.googleapis.com/osprey-downloads-c02f6a0d-347c-492b-a752-3e0651722e97/nest-win-x64/Claude-Setup-x64.exe"
        CLAUDE_EXE_FILENAME="Claude-Setup-x64.exe"
    elif [ "$architecture" = "arm64" ]; then
        CLAUDE_DOWNLOAD_URL="https://storage.googleapis.com/osprey-downloads-c02f6a0d-347c-492b-a752-3e0651722e97/nest-win-arm64/Claude-Setup-arm64.exe"
        CLAUDE_EXE_FILENAME="Claude-Setup-arm64.exe"
    else
        echo "❌ Unsupported architecture: $architecture."
        echo "   Currently, only amd64 and arm64 are supported."
        rm -rf "$build_dir"
        return 1
    fi
    
    echo "Target architecture: $architecture"
    
    # Download Claude Desktop installer
    echo "📥 Downloading Claude Desktop installer..."
    local CLAUDE_EXE_PATH="$build_dir/$CLAUDE_EXE_FILENAME"
    if ! wget -O "$CLAUDE_EXE_PATH" "$CLAUDE_DOWNLOAD_URL"; then
        echo "❌ Failed to download Claude Desktop installer."
        rm -rf "$build_dir"
        return 1
    fi
    echo "✓ Download complete: $CLAUDE_EXE_FILENAME"
    
    # Extract resources
    echo "📦 Extracting resources from installer..."
    cd "$build_dir"
    if ! 7z x -y "$CLAUDE_EXE_PATH"; then
        echo "❌ Failed to extract installer."
        cd "$SCRIPT_DIR"
        rm -rf "$build_dir"
        return 1
    fi
    
    # Find nupkg file
    local NUPKG_PATH_RELATIVE=$(find . -maxdepth 1 -name "AnthropicClaude-*.nupkg" | head -1)
    if [ -z "$NUPKG_PATH_RELATIVE" ]; then
        echo "❌ Could not find AnthropicClaude nupkg file."
        cd "$SCRIPT_DIR"
        rm -rf "$build_dir"
        return 1
    fi
    
    # Extract version from nupkg filename
    local VERSION=$(echo "$NUPKG_PATH_RELATIVE" | LC_ALL=C grep -oP 'AnthropicClaude-\K[0-9]+\.[0-9]+\.[0-9]+(?=-full|-arm64-full)')
    if [ -z "$VERSION" ]; then
        echo "❌ Could not extract version from nupkg filename: $NUPKG_PATH_RELATIVE"
        cd "$SCRIPT_DIR"
        rm -rf "$build_dir"
        return 1
    fi
    echo "✓ Detected Claude version: $VERSION"
    
    # Extract nupkg
    if ! 7z x -y "$NUPKG_PATH_RELATIVE"; then
        echo "❌ Failed to extract nupkg."
        cd "$SCRIPT_DIR"
        rm -rf "$build_dir"
        return 1
    fi
    echo "✓ Resources extracted from nupkg."
    
    # Process icons
    echo "🎨 Processing icons..."
    local EXE_RELATIVE_PATH="lib/net45/claude.exe"
    if [ ! -f "$EXE_RELATIVE_PATH" ]; then
        echo "❌ Cannot find claude.exe at expected path."
        cd "$SCRIPT_DIR"
        rm -rf "$build_dir"
        return 1
    fi
    
    if ! wrestool -x -t 14 "$EXE_RELATIVE_PATH" -o claude.ico; then
        echo "❌ Failed to extract icons from exe."
        cd "$SCRIPT_DIR"
        rm -rf "$build_dir"
        return 1
    fi
    
    if ! icotool -x claude.ico; then
        echo "❌ Failed to convert icons."
        cd "$SCRIPT_DIR"
        rm -rf "$build_dir"
        return 1
    fi
    echo "✓ Icons processed."
    
    # Create deb package structure
    echo "⚙️ Creating Debian package structure..."
    local PACKAGE_NAME="claude-desktop"
    local MAINTAINER="Claude Desktop Manager <$(whoami)@$(hostname)>"
    local DESCRIPTION="Claude Desktop for Linux - Built with Claude Desktop Manager"
    
    local DEB_ROOT="$build_dir/deb-package"
    local INSTALL_DIR="$DEB_ROOT/usr"
    
    mkdir -p "$DEB_ROOT/DEBIAN"
    mkdir -p "$INSTALL_DIR/lib/$PACKAGE_NAME"
    mkdir -p "$INSTALL_DIR/share/applications"
    mkdir -p "$INSTALL_DIR/share/icons/hicolor/256x256/apps"
    mkdir -p "$INSTALL_DIR/bin"
    
    # Process app.asar
    echo "⚙️ Processing app.asar..."
    mkdir -p "$build_dir/electron-app"
    cp "lib/net45/resources/app.asar" "$build_dir/electron-app/"
    cp -a "lib/net45/resources/app.asar.unpacked" "$build_dir/electron-app/" 2>/dev/null || true
    
    cd "$build_dir/electron-app"
    
    # Extract app.asar
    if ! npx asar extract app.asar app.asar.contents; then
        echo "❌ Failed to extract app.asar."
        cd "$SCRIPT_DIR"
        rm -rf "$build_dir"
        return 1
    fi
    
    # Create stub native module
    echo "Creating stub native module..."
    mkdir -p app.asar.contents/node_modules/claude-native
    cat > app.asar.contents/node_modules/claude-native/index.js << EOF
// Stub implementation of claude-native using KeyboardKey enum values
const KeyboardKey = { Backspace: 43, Tab: 280, Enter: 261, Shift: 272, Control: 61, Alt: 40, CapsLock: 56, Escape: 85, Space: 276, PageUp: 251, PageDown: 250, End: 83, Home: 154, LeftArrow: 175, UpArrow: 282, RightArrow: 262, DownArrow: 81, Delete: 79, Meta: 187 };
Object.freeze(KeyboardKey);
module.exports = { getWindowsVersion: () => "10.0.0", setWindowEffect: () => {}, removeWindowEffect: () => {}, getIsMaximized: () => false, flashFrame: () => {}, clearFlashFrame: () => {}, showNotification: () => {}, setProgressBar: () => {}, clearProgressBar: () => {}, setOverlayIcon: () => {}, clearOverlayIcon: () => {}, KeyboardKey };
EOF
    
    # Copy Tray icons and localization files
    mkdir -p app.asar.contents/resources
    mkdir -p app.asar.contents/resources/i18n
    cp "$build_dir/lib/net45/resources/Tray"* app.asar.contents/resources/ 2>/dev/null || true
    cp "$build_dir/lib/net45/resources/"*-*.json app.asar.contents/resources/i18n/ 2>/dev/null || true
    
    # Fix title bar issue (based on original implementation)
    echo "Fixing title bar display..."
    SEARCH_BASE="app.asar.contents/.vite/renderer/main_window/assets"
    TARGET_PATTERN="MainWindowPage-*.js"
    
    # Find the target file recursively
    TARGET_FILE=$(find "$SEARCH_BASE" -type f -name "$TARGET_PATTERN" 2>/dev/null | head -1)
    
    if [ -n "$TARGET_FILE" ] && [ -f "$TARGET_FILE" ]; then
        echo "Found target file: $TARGET_FILE"
        # Replace patterns like 'if(!VAR1 && VAR2)' with 'if(VAR1 && VAR2)'
        sed -i -E 's/if\(!([a-zA-Z]+)[[:space:]]*&&[[:space:]]*([a-zA-Z]+)\)/if(\1 \&\& \2)/g' "$TARGET_FILE"
        echo "✓ Title bar fix applied."
    else
        echo "⚠️ Could not find MainWindowPage file for title bar fix."
    fi
    
    # Repack app.asar
    if ! npx asar pack app.asar.contents app.asar; then
        echo "❌ Failed to repack app.asar."
        cd "$SCRIPT_DIR"
        rm -rf "$build_dir"
        return 1
    fi
    
    # Set up unpacked native module for asar.unpacked
    mkdir -p "$DEB_ROOT/usr/lib/$PACKAGE_NAME/app.asar.unpacked/node_modules/claude-native"
    cat > "$DEB_ROOT/usr/lib/$PACKAGE_NAME/app.asar.unpacked/node_modules/claude-native/index.js" << EOF
// Stub implementation of claude-native using KeyboardKey enum values
const KeyboardKey = { Backspace: 43, Tab: 280, Enter: 261, Shift: 272, Control: 61, Alt: 40, CapsLock: 56, Escape: 85, Space: 276, PageUp: 251, PageDown: 250, End: 83, Home: 154, LeftArrow: 175, UpArrow: 282, RightArrow: 262, DownArrow: 81, Delete: 79, Meta: 187 };
Object.freeze(KeyboardKey);
module.exports = { getWindowsVersion: () => "10.0.0", setWindowEffect: () => {}, removeWindowEffect: () => {}, getIsMaximized: () => false, flashFrame: () => {}, clearFlashFrame: () => {}, showNotification: () => {}, setProgressBar: () => {}, clearProgressBar: () => {}, setOverlayIcon: () => {}, clearOverlayIcon: () => {}, KeyboardKey };
EOF
    
    # Copy app files to debian package structure
    cp app.asar "$DEB_ROOT/usr/lib/$PACKAGE_NAME/"
    cp -r app.asar.unpacked "$DEB_ROOT/usr/lib/$PACKAGE_NAME/" 2>/dev/null || true
    
    # Copy icon
    cd "$build_dir"
    cp "claude_6_256x256x32.png" "$DEB_ROOT/usr/share/icons/hicolor/256x256/apps/claude-desktop.png"
    
    # Create desktop entry
    cat > "$DEB_ROOT/usr/share/applications/claude-desktop.desktop" << EOF
[Desktop Entry]
Name=Claude
Comment=Claude Desktop AI Assistant
Exec=claude-desktop %u
Icon=claude-desktop
Type=Application
Terminal=false
Categories=Office;Utility;
MimeType=x-scheme-handler/claude;
StartupWMClass=Claude
EOF
    
    # Create launcher script
    cat > "$DEB_ROOT/usr/bin/claude-desktop" << EOF
#!/bin/bash
electron /usr/lib/claude-desktop/app.asar "\$@"
EOF
    chmod +x "$DEB_ROOT/usr/bin/claude-desktop"
    
    # Create control file
    cat > "$DEB_ROOT/DEBIAN/control" << EOF
Package: claude-desktop
Version: $VERSION
Architecture: $architecture
Maintainer: $MAINTAINER
Depends: nodejs, npm, electron
Description: $DESCRIPTION
 Claude is an AI assistant from Anthropic.
 This package provides the desktop interface for Claude.
 .
 Built with Claude Desktop Manager (cmgr)
EOF
    
    # Build .deb package
    echo "📦 Building .deb package..."
    local DEB_FILE="$CMGR_CACHE/claude-desktop_${VERSION}_${architecture}.deb"
    
    if ! dpkg-deb --build "$DEB_ROOT" "$DEB_FILE"; then
        echo "❌ Failed to build .deb package."
        cd "$SCRIPT_DIR"
        rm -rf "$build_dir"
        return 1
    fi
    
    # Copy to current directory
    local OUTPUT_DEB="./claude-desktop_${VERSION}_${architecture}.deb"
    cp "$DEB_FILE" "$OUTPUT_DEB"
    
    # Create metadata file
    cat > "$CMGR_CACHE/metadata.json" << EOF
{
    "version": "${VERSION}",
    "format": "deb",
    "file": "claude-desktop_${VERSION}_${architecture}.deb",
    "build_date": "$(date -Iseconds)"
}
EOF
    
    # Cleanup if requested
    if [ "$cleanup" = "yes" ]; then
        echo "🧹 Cleaning up build directory..."
        rm -rf "$build_dir"
    fi
    
    echo "✅ Build complete!"
    echo "📦 Package created: $OUTPUT_DEB"
    echo ""
    echo "To install the package, run: sudo apt install $OUTPUT_DEB"
    echo "or: sudo dpkg -i $OUTPUT_DEB && sudo apt -f install"
    
    return 0
}

cmd_help() {
    show_help
}

# Main command dispatcher
main() {
    if [ $# -eq 0 ]; then
        cmd_help
        exit 0
    fi

    local command="$1"
    shift

    case "$command" in
        create)
            if [ $# -lt 1 ]; then
                echo "Error: Missing instance name"
                cmd_help
                exit 1
            fi
            cmd_create "$@"
            ;;
        list)
            cmd_list
            ;;
        start)
            if [ $# -lt 1 ]; then
                echo "Error: Missing instance name"
                cmd_help
                exit 1
            fi
            cmd_start "$@"
            ;;
        stop)
            if [ $# -lt 1 ]; then
                echo "Error: Missing instance name"
                cmd_help
                exit 1
            fi
            cmd_stop "$@"
            ;;
        remove)
            if [ $# -lt 1 ]; then
                echo "Error: Missing instance name"
                cmd_help
                exit 1
            fi
            cmd_remove "$@"
            ;;
        config)
            if [ $# -lt 1 ]; then
                echo "Error: Missing instance name"
                cmd_help
                exit 1
            fi
            cmd_config "$@"
            ;;
        alias)
            if [ $# -lt 1 ]; then
                echo "Error: Missing instance name"
                cmd_help
                exit 1
            fi
            cmd_alias "$@"
            ;;
        desktop)
            if [ $# -lt 1 ]; then
                echo "Error: Missing instance name"
                cmd_help
                exit 1
            fi
            cmd_desktop "$@"
            ;;
        mcp)
            if [ $# -lt 1 ]; then
                echo "Error: Missing instance name"
                cmd_help
                exit 1
            fi
            cmd_mcp "$@"
            ;;
        import-config)
            if [ $# -lt 1 ]; then
                echo "Error: Missing instance name"
                cmd_help
                exit 1
            fi
            cmd_import_config "$@"
            ;;
        execute)
            if [ $# -lt 1 ]; then
                echo "Error: Missing instance name"
                cmd_help
                exit 1
            fi
            cmd_execute "$@"
            ;;
        fix-warnings)
            cmd_fix_warnings "$@"
            ;;
        update-title)
            cmd_update_title "$@"
            ;;
        verify-isolation)
            cmd_verify_isolation "$@"
            ;;
        build)
            cmd_build "$@"
            ;;
        mcp-gui)
            cmd_mcp_gui
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            echo "Error: Unknown command '$command'"
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"